#!/bin/bash
# A script to backup / restore arbitrary system files from multiple hosts to a 
# shared, versioned location, while caring for file permissions (mod, uid,gui).
# The script will use aboslut pathes, to support system files. If you provide a 
# relative path, pwd will be prefixed.
# Versioning is done in git, while each hosts has it's own branch. This script
# will only commit and fetch from git, but not e.g. merge. We use the hostname
# as branch name.
#
# Depends: git, getfacl setfacl
#
# TODO: 
#   - support recursive directories
#   - restore "all"
#   - show diff, merge from other host ?
#   - run as user. Request root if necessary.
#   - create arch configuration packages?

REPO="/mnt/extHDD/backup/cfgbak.git"
BRANCH="${HOSTNAME}"
# get command line arguments and set cfg_ variables
unset OPTIND
unset OPTARG
while getopts hvdn _opts
do
    case ${_opts} in
        d)
            echo "Dry-run. No file modificaions !!"
            DRYRUN=true
            ;;
        v)
            VERBOSE=true
            ;;
        n)
            NOCOMMIT=true
            ;;
        h)
            echo "Usage: cfgbak [OPTION] [store, restore] FILE"
            echo "  -d      Dry run."
            echo "  -v      verbose"
            exit 2
            ;;
        *)
            echo "Error, unknown parameter"
            exit 2
            ;;
    esac
done
CMD=${@:$OPTIND:1}
SRC=${@:$OPTIND+1:1}

# function to execute cmd's, or just print them for dry run
function EXEC {
    if [ ${DRYRUN} ]; then
        echo "# ${1}"
    else
        [ ${VERBOSE} ] && echo "EXEC: ${1}"
        eval ${1}
        if [ $? -ne 0 ]; then
            echo "Error on executing ${1}"
            return 1
        fi
    fi
}

# create a new repo, if it does not exists
if [ ! -d ${REPO} ]; then
    echo "Error, no repo at ${REPO}"
    EXEC "git init ${REPO}"
fi

# check for branch and create if necessary
_BRANCH=$(git -C ${REPO} branch --list ${BRANCH})
if [ -n "${_BRANCH}" ]; then    # quotes needed because of space
    [ ${VERBOSE} ] && echo "Branch '${_BRANCH}' exists"
    if [ ! "${_BRANCH:0:1}" == "*" ]; then    
        EXEC "git -C ${REPO} checkout ${BRANCH}"
    fi
else
    # create an empty branch and check it out and clean working dir
    [ ${VERBOSE} ] && echo "Branch does not exists"
    EXEC "git -C ${REPO} checkout --orphan ${BRANCH}"
    EXEC "git -C ${REPO} rm -rf \*"
fi

# if relative path, prefix current path
if [ ! ${SRC:0:1} == "/" ]; then
    SRC=$(pwd)/${SRC}
fi
DST=${REPO}${SRC}

if [ ${VERBOSE} ]; then
    echo "CMD       : ${CMD}"
    echo "SRC       : ${SRC}"
    [ ${DRYRUN} ] && echo "Dry-run   : true"
    echo "Repo      : ${REPO}"
fi

case ${CMD} in
    store)
        echo "-> store ${SRC} to ${DST}"
        [ ! -f ${SRC} ] && echo "Error, src not found" && exit
        # if dst path not exists, create
        DSTPATH=$(dirname ${DST})
        [ ! -d ${DSTPATH} ] && EXEC "mkdir -p ${DSTPATH}"
        #TODO: store permissions of path
        EXEC "cp -rf ${SRC} ${DST}"
        # store file permissions
        EXEC "getfacl -p ${SRC} > ${DST}.facl"
        EXEC "git -C ${REPO} add ${DST}*"
        [ ! ${NOCOMMIT} ] && EXEC "git -C ${REPO} commit -m 'backup'"
        ;;
    restore)
        echo "-> restore ${DST} to ${SRC}"
        [ ! -f ${DST} ] && echo "Error, src not found" && exit
        SRCPATH=$(dirname ${SRC})
        EXEC "mkdir -p ${SRCPATH}"
        EXEC "cp -rf ${DST} ${SRC}"
        # restore file access control
        EXEC "setfacl --restore=${DST}.facl"
        # if fail, maybe we miss permission -> sudo
        ;;
    *)
        echo "Error, unknown command!"
        exit
        ;;
esac
